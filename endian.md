# 大端序，小端序

## 概念

数据在内存中是以字节为单位进行存储的，字节必须按规定的顺序进行存储，读取时根据规定的顺序排列字节，才能得到正确的值。显然，多字节数据有两种排列方式——正序和反序，这就引入了大端序和小端序的概念。

* 小端序（little-endian）：低位字节存储在低地址，高位字节存储在高地址。
* 大端序（big-endian）：低位字节存储在高地址，高位字节存储在低地址。

Windows、Linux都是小端序的机器，Mac OS是大端序的机器。以0x12345678为例，看看数据在内存的存储方式。

小端序
低地址----------->高地址
0x78 | 0x56 | 0x34 | 0x12

大端序
低地址----------->高地址
0x12 | 0x34 | 0x56 | 0x78

## 判断机器的端序

存储一个多字节的数据，查看每个字节的值，通过字节顺序即可判断端序。在C/C++中使用指针地址很容易访问一个字节，示例如下。
```c
#include <cstdio>

main() {
    int a = 0x12345678;
    char *b = (char *) &a;
    //little-endian: 78 56 34 12
    //big-endian: 12 34 56 78
    printf("%x %x %x %x", *b, *(b+1), *(b+2), *(b+3));
}
```

还有其他奇技淫巧能判断端序，比如使用union的共享内存特性，有兴趣的可以问问Google。

## 网络编程的端序转换

在网络编程中存在不同端序的机器进行数据传输的场景，机器之间是不知道彼此的端序的，所以网络协议必须规定传输数据的字节顺序，机器再将字节数据转换为自身的顺序进行存储。这就是网络字节序的概念，网络字节序规定为大端序。

使用以下函数进行机器端序和网络端序的转换，不同操作系统、不同语言有不同的函数库实现了这些功能。
> htons() host to network short
> htonl() host to network long
> ntohs() network to host short
> ntohl() network to host long
