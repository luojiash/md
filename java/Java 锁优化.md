# Java 锁优化

synchronized 实现了可重入的内置锁，锁的状态保存在对象头，即每个对象都可以作为一个锁。
synchronized 修饰静态方法时，使用 Class 对象作为锁，独立于实例对象的锁。通过实例对象
调用 synchronized static 方法，也需要获得 Class 对象锁，所以一个线程获得 Class 对象锁
后，其他线程以哪种方式调用 synchronized static 方法都会阻塞。

synchronized使用了多种优化技术提高效率。

## 锁消除

通过逃逸分析，对检测到不可能发生共享数据竞争的锁进行消除。

## 锁粗化

对于频繁的加锁，扩大加锁的范围。

## 自旋锁（自适应自旋）

不阻塞线程，循环等待锁可用，消耗CPU资源。

## 偏向锁

开启该特性时，第一个线程通过CAS获取偏向锁，以后只需检查对象头记录的ThreadId和自身线程id是否一致，若一致即可直接进入同步代码块。另一个线程尝试获取锁后，偏向锁膨胀为轻量级锁。

## 轻量级锁

通过CAS对象头Mark Word获取锁，CAS解锁。加锁存在竞争时（先自旋）膨胀为重量级锁。

## 重量级锁（操作系统级别）

使用互斥量，需要在用户态和内核态来回切换，代价非常高。