# Redis

## 数据结构

**简单动态字符串（simple dynamic string, SDS）**
  SDS保存了free/len/buf。
  获取字符串长度的复杂度为O(1)
  API是安全的，不会造成缓冲区溢出
  减少修改字符串长度带来的内存重分配次数
  二进制安全
  可以使用一部分<string.h>库中的函数

**双向链表**

**字典（dict）**
Redis数据库就是使用字典作为底层实现的。

**跳跃表（skiplist）**
支持平均O(logN)、最坏O(n)复杂度的节点查找。在一个跳跃表中，各个节点保存的成员对象必须是唯一的。Redis在两个地方用到了跳跃表：一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。

**整数集合（intset）**

**压缩列表（ziplist）**
用于实现列表、有序集合、哈希。


## 对象

字符串：字符串
列表：压缩列表、双向链表
哈希：压缩列表、字典

集合
编码是整数集合（intset）或字典（hashtable）

有序集合（zset）
1. 使用压缩列表（ziplist）实现
2. 使用跳跃表（skiplist）和字典（dict）实现



## 命令行

集群模式连接Redis
redis-cli -p 7000 -c
`-c` Enable cluster mode (follow -ASK and -MOVED redirections).

> OBJECT ENCODING msg

## 故障转移（Redis cluster）

集群中每个节点都会定时向集群中其他节点发送PING消息，一次来检测对方是否在线。如果接收PING消息的节点没有在规定时间内回复PONG消息，那么发送PING消息的节点会将接收PONG消息的节点标记为疑似下线（probable fail, PFAIL）。

集群中各个节点通过互相发送消息的方式来交换集群中各个节点的状态消息（gossip协议）。如果某个主节点A得知集群中半数以上主节点都将某个主节点X标记为PFAIL，那么主节点A将主节点X标记为已下线（FAIL），并向集群广播主节点X的FAIL消息，收到消息的节点立即将主节点X标记为FAIL。

在一个配置纪元（epoch），从节点向集群广播消息，要求所有具有投票权的主节点向其投票。当一个从节点收到N/2+1张支持票时（N为主节点个数），这个从节点就当选为新的主节点。

当集群中多个从节点同时发起投票，可能导致票数分散，没有一个从节点获得半数以上的投票，那么集群将进入下一个配置纪元，并再次选举，直到选出新的主节点为止。

生产环境一次事故中，Redis集群（90主节点+90从节点，5台物理机）的一台物理机宕机，导致16个主节点同时下线。从节点得知主节点下线后，等待两个超时周期cluster-node-timeout（15s，可配置），然后发起投票。最快的在一个配置纪元完成选举，即从故障到恢复持续了大概30s。

按理说不同槽的主节点选举不会冲突，且同一槽位只有一个从节点在选举，那么应该都能在一个配置纪元完成选举。实际最慢完成选举的一个节点中间失败了2次，在第三个配置纪元才选举成功，总共花了2分30秒（失败后等待1分钟进入下一个配置纪元选举，加上最开始的30s）才完成选举。可见同一物理机上不应该部署太多主节点，同时下线节点过多可能加长选举周期，拉长故障持续时间。